----------------------------------------------------------
----------------## @@@ SEGUNDA AULA @@@ ##----------------
----------------------------------------------------------

*** METODOS HTTP, REQUISIÇÕES & ROTAS ***

	Métodos HTTP:
		app.get()  // HTTP GET
			Listar informações do backend.
		app.post() // HTTP POST
			Criar uma informação no backend.
		app.put()  // HTTP PUT
			Alterar uma informação no backend.
		app.delete()  // HTTP DELETE
			Deletar uma informação do backend.

	Quando uma rota é criada precisamos informar o caminho desta rota, por
	exemplo na função app.get('/', ...), a rota sera localhost:porta/

	Geralmente o que vem depois da '/' é um recurso, app.get('/users', ...).
	Users é o recurso que queremos acessar, ele geralmente esta associado a uma
	tabela do banco de dados ou algum recurso fornecido pela aplicação.

	Tipos de Parâmetros para uma rota:
		Query Params: Parametros nomeados enviados na rota após o simbolo de '?'.
			/products?nome=geladeira
			/products?page=2&nome=geladeira

		Route Params: Parâmetros utilizados para identificar recursos.
			/products/:id

		Request Body:
			Corpo da requisição, utilizado para criar ou alterar recursos. Um
			RequestBody não precisa conter todas as propriedades do objeto que
			sera alterado mas sim as propriedades que serão modificadas.

				usuario {
					nome: "rafael"
					email: "rafael@email.com"
					endereço: "endereço,cep,numero"
				}

			RequestBody para alterar apenas o nome:
				{
					nome:"bernardes"
				}

			Acessar os Query Params => request.query
			Acessar os Route Params => request.params
			Acessar o RequestBody => request.body

			OBS request.body:
				É preciso informar para o Express que estamos utilizando
				o formato JSON nas requisições. Antes da requisição o express
				converte o JSON do RequestBody em objeto javascript.

				app.use(express.json());

*** METODOS HTTP, REQUISIÇÕES & ROTAS ***

*** NODEMON ***

	Nodemon monitora os arquivos e reinicia o servidor quando algo é alterado.
		
		npm install nodemon -D		// devDependencies
		"dev": "nodemon index.js"	// package.json
		npm run dev					// testando

*** NODEMON ***

*** BANCO DE DADOS ***

	SQL: MySQL, SQLite, postgreSQL, Oracle, Microsoft SQL Server
	NoSQL: MongoDB, couchDB...
	
	Banco de dados SQL permite um controle maior sobre a estrutura de tabelas e
	é o mais utilizada no mercado atual. Bancos NoSQL são bastante livres e
	são pouco estruturados.

	Nessa aplicação utilizaremos banco de dados SQLite, algo simples armazenado
	na própria aplicação como um arquivo do tipo .sqite.
	
	Para uma manipulação mais simples do banco de dados utilizaremos um
	QueryBuilder Knex(http://knexjs.org/):

		npm install knex
		npm install sqlite3
		npx knex init			#arquivo de cfg do knex na raiz do projeto

*** BANCO DE DADOS ***

*** ESTRUTURA DO PROJETO ***

	Projeto deve ficar com a seguinte estrutura:
		./
        └── src
			└── index.js
			└── routes.js
			└── database
				└── db.sqlite
		knexfile.js
		package.json

	- Alterar o script "dev" em package.json.
	- routes.js importa o Express e exporta const routes = express.Router().
	- index.js importa a const exportada por routes.js e dá um app.use(routes).
	- filename, no modo desenvolvimento knexfile para './src/database/db.sqlite'.

*** ESTRUTURA DO PROJETO ***

*** ENTIDADES E FUNCIONALIDADES ***

	Entidades:
		- ONG
		- Incident

	Funcionalidades:
		- Login ONG						- Logout ONG
		- Cadastrar ONG					- Cadastras novos casos
		- Deletar casos					- Listar casos especificos de uma ONG
		- Listar todos os casos			- Contato com a ONG

*** ENTIDADES E FUNCIONALIDADES ***

*** CRIANDO TABELAS NO BANCO DE DADOS ***

	Tabelas serão criadas com Migrations(http://knexjs.org/#Migrations).
	Migrations: As migrações permitem que você defina conjuntos de alterações
	de esquema, portanto é fácil atualizar um banco de dados.

	- Criar pasta 'migrations' dentro de 'database'.
	- Em knexfile.js, dentro da configuração development após connection:
		  ...
		  	},
		  	migrations: {
				  directory: './src/database/migrations
			},
			useNullAsDefault: true
		  ...

			useNullAsDefault evita o seguinte warning:
		  		"sqlite does not support inserting default values. Set the
				`useNullAsDefault` flag to hide this warning."

	- Criando tabela para entidade ONGS:
		npx knex migrate:make create_ongs

		Um arquivo será gerado na pasta migrations, a tabela deve ser criada a
		partir do método:
			exports.up = function(knex) {
				http://knexjs.org/#Schema-createTable
			};

		criar tabela: npx knex migrate:latest
		
	- Criando tabela para entidade Incidents:
		npx knex migrate:make create_incidents

		Um arquivo será gerado na pasta migrations, a tabela deve ser criada a
		partir do método:
			exports.up = function(knex) {
				http://knexjs.org/#Schema-createTable
			};

		Criar uma coluna para indicar qual é a ONG responsável pelo cadastro do
		incidente. A coluna deve ser do mesmo tipo da primary key de ongs:

			table.string('ong_id').notNullable();
        	table.foreign('ong_id').references('id').inTable('ongs');  // fk ongs

		criar tabela: npx knex migrate:latest
		
*** CRIANDO TABELAS NO BANCO DE DADOS ***

Conexão com o Banco de Dados através do arquivo /src/database/connection.js
Organizando aplicação, criando pasta controller e arquivo OngController.js
Lógica para inserir/listar ongs no arquivo OngController.js

***
	Inserir/Deletar um Incident: {

		- É preciso estar 'autenticado' como uma ONG, isso é feito obtendo o id da
		ONG no header da requisição.

		- Criar uma requisição no Insomnia, dentro da requisão editar o header:
			New header: Authorization	New value: ong_id
	
		- Buscar o id da ONG no header:
			const ong_id = req.headers.authorization;

	}

	Deletar um Incidente: {
		
		- Verificar se o incidente pertence a ONG autenticada.
		- Buscar incidente baseado no RouteParam chamado id.
		- Selecionar coluna ong_id do incidente no Banco de Dados.
		- Verificar se ong_id do BD corresponde a ong_ind do header.

			iguais => deletar e responder com status code 204.
			diferentes => retornar resposta  com status code 401 e nao deletar.
	}
***

***
	Listar casos especificos de uma ONG:

		Poderiamos criar um método no controller de incidents para listar os
		casos especificos de uma ONG mas se tivermos duas listagens em uma 
		mesma entidade é legal que criemos um novo controller para lidar com
		estas listagens extras.

		Criar um ProfileController.js
			- Buscar ong_id no header da requisição.
			- Buscar os incidents baseados no ong_id do banco de dados.
			- Listar os casos recuperados.
***

***
	Login na aplicação:
		A rota de login nada mais é do que uma rota que irá verificar se a ONG existe
		ou não.

	Criar SessionController.js e uma função create(req, res)
		- pegar id no body da requisição.
		- buscar uma ONG no BD e retornar seu nome.
		- se !ong_name => retorna status 400.
		- retorna json(ong_name).

	Criar rota post '/sessions' com a função create.
		- routes.post('/session', sessionController.create);
***

***
	Para realizar paginação dos incidentes (quebrar a quantidade de registros
	mostrados por pagina) e retornar os dados da ONG junto ao incidente vamos
	alterar o método index em IncidentController.js

	1 - Obter o QueryParam chamado page, caso não exista use page = 1:
			const {page = 1} = request.query;
	
	2 - Configurar a consulta ao BD:

		Realizar join com a tabela ongs:
			.join('ongs', 'ongs.id', '=', 'incidents.ong_id') 

		Configurar a paginação:
			.limit(5)  // retorna um numero máximo incidents.
			.offset((page - 1) * 5)  // pulando registros, buscando de n em n.

		Coluna id tem o mesmo nome nas tabelas 'ongs' e 'incidents'. Quando o
		join é realizado, o id de 'ongs' sobrepoe o id de 'incidents' mas queremos
		retornar o id de 'incidents', então alteramos a projeção das informaçoes:
			.select(
				[
				'incidents.*',
				'ongs.name',
				'ongs.email',
				'ongs.whatsapp',
				'ongs.city',
				'ongs.uf'
				]
			);

		Uma boa prática é passar para o FrontEnd o total de registos no BD, esse
		valor é enviado através do header da resposta:
			const [count] = await connection('incidents').count();  // retorna um array
			console.log(count);  // {'count(*)': 14}
			res.header('X-Total-Count', count['count(*)']);  // response header
***

***
	Modulo de segurança cors:
		npm install cors

	Determina quem pode acessar nossa aplicação.
	Importar o cors no index.js, depois de declarar o app:
		app.use(cors());
***

----------------------------------------------------------
---------------## @@@ TERCEIRA AULA @@@ ##----------------
----------------------------------------------------------

1 - Criando Projeto...
			Criando diretorio (frontend) e projeto React:
				npx create-react-app frontend

2 - Organizando Projeto...
			Deixar o projeto com a seguinte estrutura:
					./
						└── public
						└── favicon.ico
						└── index.html
					└── src
						└── App.js
						index.js
					.gitignore
					package.json
					yarn.lock

3 - Renderização...
			index.html possui uma div com id="root" sem conteúdo, porém ao rodar a apli-
			cação essa div é preenchida com um <h1> vindo de App.js, como isso acontece?

	3.1 - Passos do React:
					- Monta a estrutura da pagina(html/css) a partir do javascript.
					- Javascript entra em execução depois que o html estiver montado.
					- Javascript é executado e preenche a <div> com <h1>.
	
	3.2 - index.js
					import React from 'react';
					import ReactDOM from 'react-dom';
					import App from './App';
					
				O componente App é renderizado dentro do elemento html root:
					ReactDOM.render(<App />, document.getElementById('root'));
			
	3.3 - Componente em App.js:
					export default function App() {
						return ( <h1>Hello World</h1> );
					}

4 - Componentes...
			No React, um componente nada mais é  do que uma função que retorna um HTML.

	4.1 - JSX...
				HTML escrito no javascript é chamado de JSX.

5 - Propriedades...

		Imagine uma página web com um cabeçalho que se repete em diferentes guias,
		vamos modularizar isso criando um componente customizavel chamado Header.

		- Criar um arquivo Header.js na pasta src.
		- Criar e exportar a seguinte função(componente):
					export default function Header() {
						return (
        			<header>
            		<h1>Header Component.</h1>
        			</header>
    				);	
					}
		
		- Importar Header.js em App.js
		- Criar e exportar a seguinte função:
				export function App() {
  				return (<Header />);
				}
		
		- Importar App.js em index.js
		- Renderizar utilizando ReactDom.render();
	
6 - Estado...

		Seja uma informação(variavel, listagem etc) armazenada em um componente, não
		podemos modifica-la de maneira convencional, por exemplo:
				counter = counter + 1
				counter++
				etc.
		no React, precisamos utilizar o conceito de Estado para modificar informaçoes.
		"Sempre que o estado for alterado o componente é renderizado novamente,
		exibindo as novas informações em tela."

	imutabilidade: por uma questão de performance não podemos alterar o valor do
	estado de um forma direta, o valor deve ser sobreposto.

			useState() => retorna um array [valorVariavel, funcaoAtualização]
			const [counter, seCounter] = useState(0);

	